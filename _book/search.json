[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Differential Geometry",
    "section": "",
    "text": "Preface\nWelcome to the Lecture Notes of Differential Geometry 600727 for T1 2023 at the University of Hull. I will follow these lecture notes during the course. If you have any question or find any typo, please email me at\nUp to date informations about the course and homework will be published on the course webpage\nA pdf version of the notes is available to download on the top-right."
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Differential Geometry",
    "section": "References",
    "text": "References\nWe will study curves and surfaces in \\(\\mathbb{R}^3\\). I will follow mainly the textbook by Pressley [1]. Other references that inspired these notes are the books by do Carmo [2], O’Neill [3] and Bär [4].\nI will assume some knowledge from Analysis and Linear Algebra. A good place to revise these topics are the books by Zorich [5,6]. In addition, it can be helpful to plot curves and surfaces to aid visualization. I will do this with Python 3. I recommend installation through Anaconda or Miniconda. The actual coding can then be done through, for example, Jupyter Notebook. Good references for scientific Python programming are [7,8].\n\n\n\n\n\n\nImportant\n\n\n\nYou are not expected to purchase any of the above books. These lecture notes will cover 100% of the topics you are expected to known in order to excel in the final exam.\n\n\n\n\n\n\n[1] A. Pressley, Elementary differential geometry, Second Edition, Springer, 2010.\n\n\n[2] M.P. do Carmo, Differential geometry of curves and surfaces, Second Edition, Dover Books on Mathematics, 2017.\n\n\n[3] B. O’Neill, Elementary differential geometry, Second Edition, Academic Press, 2006.\n\n\n[4] C. Bär, Elementary differential geometry, Cambridge University Press, 2010.\n\n\n[5] V.A. Zorich, Mathematical analysis i, Second Edition, Springer, 2015.\n\n\n[6] V.A. Zorich, Mathematical analysis II, Second Edition, Springer, 2016.\n\n\n[7] R. Johansson, Numerical python. Scientific computing and data science applications with numpy, SciPy and matplotlib, Second Edition, Apress, 2019.\n\n\n[8] Q. Kong, T. Siauw, A. Bayen, Python programming and numerical methods, Academic Press, 2020."
  },
  {
    "objectID": "sections/license.html#reuse",
    "href": "sections/license.html#reuse",
    "title": "License",
    "section": "Reuse",
    "text": "Reuse\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License"
  },
  {
    "objectID": "sections/license.html#citation",
    "href": "sections/license.html#citation",
    "title": "License",
    "section": "Citation",
    "text": "Citation\nFor attribution, please cite this work as:\n\nFanzon, Silvio. (2023). Lecture Notes on Differential Geometry.\nhttps://silviofanzon.quarto.pub/2023-differential-geometry/\n\nBibTex citation:\n@electronic{fanzon-diff-geom-2023,\n    author = {Fanzon, Silvio},\n    title = {Lecture Notes on Differential Geometry},\n    url = {https://silviofanzon.quarto.pub/2023-differential-geometry/},\n    year = {2023}}"
  },
  {
    "objectID": "sections/chap1.html#plotting-curves-with-python",
    "href": "sections/chap1.html#plotting-curves-with-python",
    "title": "1  Curves",
    "section": "1.1 Plotting curves with Python",
    "text": "1.1 Plotting curves with Python\n\n1.1.1 Plotting 2D curves\nSuppose we want to plot the parabola \\(y=t^2\\) for \\(t\\) in the interval \\([-3,3]\\). In our language, this is the two-dimensional curve \\[\n\\gamma(t) = ( t, t^2 ) \\,, \\quad  t \\in [-3,3] \\,.\n\\] The two Python libraries we use to plot \\(\\gamma\\) are numpy and matplotlib. In short, numpy handles multi-dimensional arrays and matrices, and can perform high-level mathematical functions on them. For any question you may have about numpy, answers can be found in the searchable documentation available here. Instead matplotlib is a plotting library, with documentation here. Python libraries need to be imported every time you want to use them. In our case we will import:\nimport numpy as np\nimport matplotlib.pyplot as plt\nThe above imports numpy and the module pyplot from matplotlib, and renames them to np and plt, respectively. These shorthands are standard in the literature, and they make code much more readable.\nThe module for plotting 2D graphs is called plot(x,y) and is contained in plt. As the syntax suggests, plot takes as arguments two arrays \\(x=[x_1, \\ldots, x_n]\\) and \\(y=[y_1,\\ldots,y_n]\\). As output it produces a graph which is the linear interpolation of the points \\((x_i,y_i)\\) in \\(\\mathbb{R}^2\\), that is, consecutive points \\((x_i,y_i)\\) and \\((x_{i+1},y_{i+1})\\) are connected by a segment. Using plot, we can graph the curve \\(\\gamma(t)=(t,t^2)\\) like so:\n\n# Code for plotting gamma\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.array([-3,-2,-1,0,1,2,3])\nf = t**2\nplt.plot(t,f)\nplt.plot(t,f,\"ko\")\nplt.show()\n\n\n\n\nLet us comment the above code. The variable t is a numpy array containing the ordered values \\[\nt = [-3,-2,-1,0,1,2,3]\\,.\n\\tag{1.1}\\] This array is then squared entry-by-entry via the operation \\(t\\ast\\!\\ast 2\\) and saved in the new numpy array f, that is, \\[\nf = [9,4,1,0,1,4,9] \\,.\n\\] The arrays t and f are then passed to plot(t,f), which produces the above linear interpolation, with t on the x-axis and f on the y-axis. The command plot(t,f,'ko') instead plots a black dot at each point \\((t_i,f_i)\\). The latter is clearly not needed to obtain a plot, and it was only included to highlight the fact that plot is actually producing a linear interpolation between points. Finally plt.show() displays the figure in the user window1.\nOf course one can refine the plot so that it resembles the continuous curve \\(\\gamma(t)=(t,t^2)\\) that we all have in mind. This is achieved by generating a numpy array t with a finer stepsize, invoking the function np.linspace(a,b,n). Such call will return a numpy array which contains n evenly spaced points, starts at a, and ends in b. For example np.linspace(-3,3,7) returns our original array t at Equation 2.1, as shown below\n\n# Displaying output of np.linspace\n\nimport numpy as np\n\nt = np.linspace(-3,3, 7)\nprint(\"t =\", t)\n\nt = [-3. -2. -1.  0.  1.  2.  3.]\n\n\nIn order to have a more refined plot of \\(\\gamma\\), we just need to increase \\(n\\).\n\n# Plotting gamma with finer step-size\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.linspace(-3,3, 100)\nf = t**2\nplt.plot(t,f)\nplt.show()\n\n\n\n\nLet us now plot something more interesting, such as the two-dimensional curve known as the Fermat’s spiral \\[\n\\gamma(t) = ( \\sqrt{t}  \\cos(t) , \\sqrt{t}  \\sin(t) ) \\quad\n\\text{ for } \\quad t \\in [0,50] \\,.\n\\] Clearly we need to modify the above code. The variable t will still be a numpy array produced by linspace. We then need to introduce the arrays x and y which ecode the first and second components of \\(\\gamma\\), respectively.\n# Plotting Fermat's spiral\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.linspace(0,50, 500)\nx = np.sqrt(t) * np.cos(t)\ny = np.sqrt(t) * np.sin(t)\n\nplt.plot(x,y)\nplt.show()\nBefore displaying the output of the above code, a few comments are in order. The array t has size 500, due to the behavior of linspace. You can also fact check this information by printing np.size(t), which is the numpy function that returns the size of an array. We then use the numpy function np.sqrt to compute the square root of the array t. The outcome is still an array with the same size of t, that is, \\[\nt=[t_1,\\ldots,t_n]   \\quad \\implies \\quad \\sqrt{t} = [\\sqrt{t_1}, \\ldots, \\sqrt{t_n}] \\,.\n\\] Similary, the call np.cos(t) returns the array \\[\n\\cos(t) = [\\cos(t_1), \\ldots, \\cos(t_n)] \\,.\n\\] The two arrays np.sqrt(t) and np.cos(t) are then multiplied, term-by-term, and saved in the array x. The array y is computed similarly. The command plt.plot(x,y) then yields the graph of the Fermat’s spiral:\n\n\n\n\n\nFermat’s spiral\n\n\n\n\nThe above plots can be styled a bit. For example we can give a title to the plot, label the axes, plot the spiral by means of green dots, and add a plot legend, as coded below:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.linspace(0,50, 500)\nx = np.sqrt(t) * np.cos(t)\ny = np.sqrt(t) * np.sin(t)\n\nplt.figure(1, figsize = (5,5))\n\nplt.plot(x, y, \"--\", color=\"deeppink\", linewidth=1.5, label=\"Spiral\")\nplt.grid(True, color=\"lightgray\")\nplt.title(\"Fermat's spiral for t between 0 and 50\")\nplt.xlabel(\"x-axis\", fontsize = 15)\nplt.ylabel(\"y-axis\", fontsize = 15)\nplt.legend()\nplt.show()\n\n\n\n\nAdding a bit of style\n\n\n\n\nLet us go over the novel part of the above code:\n\nplt.figure(): This command generates a figure object. If you are planning on plotting just one figure at a time, then this command is optional: a figure object is generated implicitly when calling plt.plot. Otherwise, if working with n figures, you need to generate a figure object with plt.figure(i) for each i between 1 and n. The number i uniquely identifies the i-th figure: whenever you call plt.figure(i), Python knows that the next commands will refer to the i-th figure. In our case we only have one figure, so we have used the identifier 1. The second argument figsize = (a,b) in plt.figure() specifies the size of figure 1 in inches. In this case we generated a figure 5 by 5 inches.\nplt.plot: This is plotting the arrays x and y, as usual. However we are adding a few aestethic touches: the curve is plotted in dashed style with --, in deep pink color and with a line width of 1.5. Finally this plot is labelled Spiral.\nplt.grid: This enables a grid in light gray color.\nplt.title: This gives a title to the figure, displayed on top.\nplt.xlabel and plt.ylabel: These assign labels to the axes, with font size 15 points.\nplt.legend(): This plots the legend, with all the labels assigned in the plt.plot call. In this case the only label is Spiral.\n\n\n\n\n\n\n\nMatplotlib styles\n\n\n\nThere are countless plot types and options you can specify in matplotlib, see for example the Matplotlib Gallery. Of course there is no need to remember every single command: a quick Google search can do wonders.\n\n\n\n\n\n\n\n\nGenerating arrays\n\n\n\nThere are several ways of generating evenly spaced arrays in Python. For example the function np.arange(a,b,s) returns an array with values within the half-open interval \\([a,b)\\), with spacing between values given by s. For example\n\nimport numpy as np\n\nt = np.arange(0,1, 0.2)\nprint(\"t =\",t)\n\nt = [0.  0.2 0.4 0.6 0.8]\n\n\n\n\n\n\n1.1.2 Plotting implicitly defined curves in 2D\nA curve \\(\\gamma\\) in \\(\\mathbb{R}^2\\) can also be defined as the set of points \\((x,y) \\in \\mathbb{R}^2\\) satisfying \\[\nf(x,y)=0\n\\] for some given \\(f \\colon \\mathbb{R}^2 \\to \\mathbb{R}\\). For example let us plot the curve \\(\\gamma\\) implicitly defined by \\[\nf(x,y) =( 3 x^2 - y^2 )^2 \\ y^2  -  (x^2 + y^2 )^4\n\\] for \\(-1 \\leq x,y \\leq 1\\). First, we need a way to generate a grid in \\(\\mathbb{R}^2\\) so that we can evaluate \\(f\\) on such grid. To illustrate how to do this, let us generate a grid of spacing 1 in the 2D square \\([0,4]^2\\). The goal is to obtain the 5 x 5 matrix of coordinates \\[\nA = \\left(\n\\begin{matrix}\n(0,0) &  (1,0)  &  (2,0) & (3,0) & (4,0) \\\\\n(0,1) &  (1,1)  &  (2,1) & (3,1) & (4,1) \\\\\n(0,2) &  (1,2)  &  (2,2) & (2,3) & (2,4) \\\\\n(0,3) &  (1,3)  &  (2,3) & (3,3) & (3,4) \\\\\n(0,4) &  (1,4)  &  (2,4) & (3,4) & (4,4) \\\\\n\\end{matrix}\n\\right)    \n\\] which corresponds to the grid of points\n\n\n\n\n\nFigure 1.1: The 5 x 5 grid corresponding to the matrix A\n\n\n\n\nTo achieve this, first generate x and y coordinates using linspace(0,4, 5). We would then obtain coordinates \\[\nx = [0, 1, 2, 3, 4] \\,, \\quad  y = [0, 1, 2, 3, 4] \\,.\n\\] We then need to obtain two matrices \\(X\\) and \\(Y\\): one for the \\(x\\) coordinates in \\(A\\), and one for the \\(y\\) coordinates in \\(A\\). Thus \\[\nX = \\left(\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 \\\\\n0 & 1 & 2 & 3 & 4 \\\\\n0 & 1 & 2 & 3 & 4 \\\\\n0 & 1 & 2 & 3 & 4 \\\\\n\\end{matrix}\n\\right)   \\,, \\quad\nY =\n\\left(\n\\begin{matrix}\n0 &  0 &  0 & 0 & 0 \\\\\n1 &  1 &  1 & 1 & 1 \\\\\n2 &  2 &  2 & 2 & 2 \\\\\n3 &  3 &  3 & 3 & 3 \\\\\n4 &  4 &  4 & 4 & 4 \\\\\n\\end{matrix}\n\\right)   \n\\]\nIf now we plot \\(X\\) against \\(Y\\) via the command\nplt.plot(X,Y, marker='.', color='k', linestyle='none')\nwe obtain Figure 1.1. This would be very tedious to do with large vectors. Thankfully there is a function in numpy doing exactly what we need: np.meshgrid.\n\n# Demonstrating np.meshgrid\n\nimport numpy as np\n\nxlist = np.linspace(0, 4, 5)\nylist = np.linspace(0, 4, 5)\nX, Y = np.meshgrid(xlist, ylist)\n\n# np.array2string is only needed to align outputs\nprint('X =', np.array2string(X, prefix='X= '))\nprint('\\n')  \nprint('Y =', np.array2string(Y, prefix='Y= '))\n\nX = [[0. 1. 2. 3. 4.]\n    [0. 1. 2. 3. 4.]\n    [0. 1. 2. 3. 4.]\n    [0. 1. 2. 3. 4.]\n    [0. 1. 2. 3. 4.]]\n\n\nY = [[0. 0. 0. 0. 0.]\n    [1. 1. 1. 1. 1.]\n    [2. 2. 2. 2. 2.]\n    [3. 3. 3. 3. 3.]\n    [4. 4. 4. 4. 4.]]\n\n\nNow that we have our grid, we can evaluate the function \\(f\\) on it. This is simply done with the command\nZ =((3*(X**2) - Y**2)**2)*(Y**2) - (X**2 + Y**2)**4 \n\n# Plotting f=0\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nxlist = np.linspace(-1, 1, 5000)\nylist = np.linspace(-1, 1, 5000)\nX, Y = np.meshgrid(xlist, ylist)\n\nZ =((3*(X**2) - Y**2)**2)*(Y**2) - (X**2 + Y**2)**4 \n\nplt.figure(figsize = (5.5,5.5))\nplt.contour(X, Y, Z, [0])\nplt.xlabel(\"x-axis\", fontsize = 15)\nplt.ylabel(\"y-axis\", fontsize = 15)\nplt.show()\n\n\n\n\nPlot of the curve defined by f=0\n\n\n\n\n\n\n1.1.3 Plotting 3D curves\nIf you have understood how to plot 2D curves in Section 1.1.1, then plotting 3D curves will not be much more difficult."
  },
  {
    "objectID": "sections/chap1.html#footnotes",
    "href": "sections/chap1.html#footnotes",
    "title": "1  Curves",
    "section": "",
    "text": "The command plt.show() can be omitted if working in Jupyter Notebook, as it is called by default.↩︎"
  },
  {
    "objectID": "sections/chap2.html#plotting-surfaces-with-python",
    "href": "sections/chap2.html#plotting-surfaces-with-python",
    "title": "2  Surfaces",
    "section": "2.1 Plotting surfaces with Python",
    "text": "2.1 Plotting surfaces with Python\nSuppose we want to plot the parabola \\(y=t^2\\) for \\(t\\) in the interval \\([-3,3]\\). In our language, this is the two-dimensional curve \\[\n\\gamma(t) = ( t, t^2 ) \\,, \\quad  t \\in [-3,3] \\,.\n\\] The two Python libraries we use to plot \\(\\gamma\\) are numpy and matplotlib. In short, numpy handles multi-dimensional arrays and matrices, and can perform high-level mathematical functions on them. For any question you may have about numpy, answers can be found in the searchable documentation available here. Instead matplotlib is a plotting library, with documentation here. Python libraries need to be imported every time you want to use them. In our case we will import:\nimport numpy as np\nimport matplotlib.pyplot as plt\nThe above imports numpy and the module pyplot from matplotlib, and renames them to np and plt, respectively. These shorthands are standard in the literature, and they make code much more readable.\nThe module for plotting 2D graphs is called plot(x,y) and is contained in plt. As the syntax suggests, plot takes as arguments two arrays \\(x=[x_1, \\ldots, x_n]\\) and \\(y=[y_1,\\ldots,y_n]\\). As output it produces a graph which is the linear interpolation of the points \\((x_i,y_i)\\) in \\(\\mathbb{R}^2\\), that is, consecutive points \\((x_i,y_i)\\) and \\((x_{i+1},y_{i+1})\\) are connected by a segment. Using plot, we can graph the curve \\(\\gamma(t)=(t,t^2)\\) like so:\n\n# Code for plotting gamma\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.array([-3,-2,-1,0,1,2,3])\nf = t**2\nplt.plot(t,f)\nplt.plot(t,f,\"ko\")\nplt.show()\n\n\n\n\nLet us comment the above code. The variable t is a numpy array containing the ordered values \\[\nt = [-3,-2,-1,0,1,2,3]\\,.\n\\tag{2.1}\\] This array is then squared entry-by-entry via the operation \\(t\\ast\\!\\ast 2\\) and saved in the new numpy array f, that is, \\[\nf = [9,4,1,0,1,4,9] \\,.\n\\] The arrays t and f are then passed to plot(t,f), which produces the above linear interpolation, with t on the x-axis and f on the y-axis. The command plot(t,f,'ko') instead plots a black dot at each point \\((t_i,f_i)\\). The latter is clearly not needed to obtain a plot, and it was only included to highlight the fact that plot is actually producing a linear interpolation between points. Finally plt.show() displays the figure in the user window1.\nOf course one can refine the plot so that it resembles the continuous curve \\(\\gamma(t)=(t,t^2)\\) that we all have in mind. This is achieved by generating a numpy array t with a finer stepsize, invoking the function np.linspace(a,b,n). Such call will return a numpy array which contains n evenly spaced points, starts at a, and ends in b. For example np.linspace(-3,3,7) returns our original array t at Equation 2.1, as shown below\n\n# Displaying output of np.linspace\n\nimport numpy as np\n\nt = np.linspace(-3,3, 7)\nprint(\"t =\", t)\n\nt = [-3. -2. -1.  0.  1.  2.  3.]\n\n\nIn order to have a more refined plot of \\(\\gamma\\), we just need to increase \\(n\\).\n\n# Plotting gamma with finer step-size\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.linspace(-3,3, 100)\nf = t**2\nplt.plot(t,f)\nplt.show()\n\n\n\n\nLet us now plot something more interesting, such as the two-dimensional curve known as the Fermat’s spiral \\[\n\\gamma(t) = ( \\sqrt{t}  \\cos(t) , \\sqrt{t}  \\sin(t) ) \\quad\n\\text{ for } \\quad t \\in [0,50] \\,.\n\\] Clearly we need to modify the above code. The variable t will still be a numpy array produced by linspace. We then need to introduce the arrays x and y which ecode the first and second components of \\(\\gamma\\), respectively.\n# Plotting Fermat's spiral\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.linspace(0,50, 500)\nx = np.sqrt(t) * np.cos(t)\ny = np.sqrt(t) * np.sin(t)\n\nplt.plot(x,y)\nplt.show()\nBefore displaying the output of the above code, a few comments are in order. The array t has size 500, due to the behavior of linspace. You can also fact check this information by printing np.size(t), which is the numpy function that returns the size of an array. We then use the numpy function np.sqrt to compute the square root of the array t. The outcome is still an array with the same size of t, that is, \\[\nt=[t_1,\\ldots,t_n]   \\quad \\implies \\quad \\sqrt{t} = [\\sqrt{t_1}, \\ldots, \\sqrt{t_n}] \\,.\n\\] Similary, the call np.cos(t) returns the array \\[\n\\cos(t) = [\\cos(t_1), \\ldots, \\cos(t_n)] \\,.\n\\] The two arrays np.sqrt(t) and np.cos(t) are then multiplied, term-by-term, and saved in the array x. The array y is computed similarly. The command plt.plot(x,y) then yields the graph of the Fermat’s spiral:\n\n\n\n\n\nFermat’s spiral\n\n\n\n\nThe above plots can be styled a bit. For example we can give a title to the plot, label the axes, plot the spiral by means of green dots, and add a plot legend, as coded below:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.linspace(0,50, 500)\nx = np.sqrt(t) * np.cos(t)\ny = np.sqrt(t) * np.sin(t)\n\nplt.figure(1, figsize = (5,5))\n\nplt.plot(x, y, \"--\", color=\"deeppink\", linewidth=1.5, label=\"Spiral\")\nplt.grid(True, color=\"lightgray\")\nplt.title(\"Fermat's spiral for t between 0 and 50\")\nplt.xlabel(\"x-axis\", fontsize = 15)\nplt.ylabel(\"y-axis\", fontsize = 15)\nplt.legend()\nplt.show()\n\n\n\n\nAdding a bit of style\n\n\n\n\nLet us go over the novel part of the above code:\n\nplt.figure(): This command generates a figure object. If you are planning on plotting just one figure at a time, then this command is optional: a figure object is generated implicitly when calling plt.plot. Otherwise, if working with n figures, you need to generate a figure object with plt.figure(i) for each i between 1 and n. The number i uniquely identifies the i-th figure: whenever you call plt.figure(i), Python knows that the next commands will refer to the i-th figure. In our case we only have one figure, so we have used the identifier 1. The second argument figsize = (a,b) in plt.figure() specifies the size of figure 1 in inches. In this case we generated a figure 5 by 5 inches.\nplt.plot: This is plotting the arrays x and y, as usual. However we are adding a few aestethic touches: the curve is plotted in dashed style with --, in deep pink color and with a line width of 1.5. Finally this plot is labelled Spiral.\nplt.grid: This enables a grid in light gray color.\nplt.title: This gives a title to the figure, displayed on top.\nplt.xlabel and plt.ylabel: These assign labels to the axes, with font size 15 points.\nplt.legend(): This plots the legend, with all the labels assigned in the plt.plot call. In this case the only label is Spiral.\n\n\n\n\n\n\n\nMatplotlib styles\n\n\n\nThere are countless plot types and options you can specify in matplotlib, see for example the Matplotlib Gallery. Of course there is no need to remember every single command: a quick Google search can do wonders.\n\n\n\n\n\n\n\n\nGenerating arrays\n\n\n\nThere are several ways of generating evenly spaced arrays in Python. For example the function np.arange(a,b,s) returns an array with values within the half-open interval \\([a,b)\\), with spacing between values given by s. For example\n\nimport numpy as np\n\nt = np.arange(0,1, 0.2)\nprint(\"t =\",t)\n\nt = [0.  0.2 0.4 0.6 0.8]"
  },
  {
    "objectID": "sections/chap2.html#footnotes",
    "href": "sections/chap2.html#footnotes",
    "title": "2  Surfaces",
    "section": "",
    "text": "The command plt.show() can be omitted if working in Jupyter Notebook, as it is called by default.↩︎"
  },
  {
    "objectID": "sections/references.html",
    "href": "sections/references.html",
    "title": "References",
    "section": "",
    "text": "[1] R.\nJohansson, Numerical python. Scientific computing and data science\napplications with numpy, SciPy and matplotlib, Second Edition, Apress,\n2019.\n\n\n[2] Q.\nKong, T. Siauw, A. Bayen, Python programming and numerical methods,\nAcademic Press, 2020.\n\n\n[3] C.\nBär, Elementary differential geometry, Cambridge University Press,\n2010.\n\n\n[4] B.\nO’Neill, Elementary differential geometry, Second Edition, Academic\nPress, 2006.\n\n\n[5] M.P. do Carmo, Differential geometry of curves\nand surfaces, Second Edition, Dover Books on Mathematics, 2017.\n\n\n[6] A.\nPressley, Elementary differential geometry, Second Edition, Springer,\n2010.\n\n\n[7] V.A. Zorich, Mathematical analysis II, Second\nEdition, Springer, 2016.\n\n\n[8] V.A. Zorich, Mathematical analysis i, Second\nEdition, Springer, 2015."
  }
]